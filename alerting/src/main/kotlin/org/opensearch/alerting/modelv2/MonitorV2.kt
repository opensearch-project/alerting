/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.alerting.modelv2

import org.opensearch.alerting.modelv2.PPLSQLMonitor.Companion.PPL_SQL_MONITOR_TYPE
import org.opensearch.common.CheckedFunction
import org.opensearch.commons.alerting.model.Schedule
import org.opensearch.commons.alerting.model.ScheduledJob
import org.opensearch.commons.authuser.User
import org.opensearch.core.ParseField
import org.opensearch.core.common.io.stream.StreamInput
import org.opensearch.core.common.io.stream.StreamOutput
import org.opensearch.core.xcontent.NamedXContentRegistry
import org.opensearch.core.xcontent.ToXContent
import org.opensearch.core.xcontent.XContentBuilder
import org.opensearch.core.xcontent.XContentParser
import org.opensearch.core.xcontent.XContentParserUtils
import java.io.IOException
import java.time.Instant

/**
 * Monitor V2 interface. All v2 monitors of different types must implement this interface.
 *
 * @opensearch.experimental
 */
interface MonitorV2 : ScheduledJob {
    override val id: String
    override val version: Long
    override val name: String
    override val enabled: Boolean
    override val schedule: Schedule
    override val lastUpdateTime: Instant // required for scheduled job maintenance
    override val enabledTime: Instant? // required for scheduled job maintenance
    val description: String?
    val user: User?
    val triggers: List<TriggerV2>
    val schemaVersion: Int // for updating monitors
    val lookBackWindow: Long? // how far back to look when querying data during monitor execution
    val timestampField: String? // field that will be used to inject lookback window time filter

    fun asTemplateArg(): Map<String, Any?>

    fun toXContentWithUser(builder: XContentBuilder, params: ToXContent.Params): XContentBuilder

    fun makeCopy(
        id: String = this.id,
        version: Long = this.version,
        name: String = this.name,
        enabled: Boolean = this.enabled,
        schedule: Schedule = this.schedule,
        lastUpdateTime: Instant = this.lastUpdateTime,
        enabledTime: Instant? = this.enabledTime,
        description: String? = this.description,
        user: User? = this.user,
        // no support for overriding triggers in interface-level makeCopy(),
        // triggers can be copied at instance-level data class copy()
        schemaVersion: Int = this.schemaVersion,
        lookBackWindow: Long? = this.lookBackWindow,
        timestampField: String? = this.timestampField
    ): MonitorV2

    enum class MonitorV2Type(val value: String) {
        PPL_SQL_MONITOR(PPL_SQL_MONITOR_TYPE);

        override fun toString(): String {
            return value
        }

        companion object {
            fun enumFromString(value: String): MonitorV2Type? {
                return MonitorV2Type.entries.find { it.value == value }
            }
        }
    }

    companion object {
        // scheduled job field names
        const val MONITOR_V2_TYPE = "monitor_v2" // scheduled job type is MonitorV2

        // field names
        const val NAME_FIELD = "name"
        const val ENABLED_FIELD = "enabled"
        const val SCHEDULE_FIELD = "schedule"
        const val LAST_UPDATE_TIME_FIELD = "last_update_time"
        const val ENABLED_TIME_FIELD = "enabled_time"
        const val DESCRIPTION_FIELD = "description"
        const val USER_FIELD = "user"
        const val TRIGGERS_FIELD = "triggers"
        const val SCHEMA_VERSION_FIELD = "schema_version"
        const val LOOK_BACK_WINDOW_FIELD = "look_back_window_minutes"
        const val TIMESTAMP_FIELD = "timestamp_field"

        // default values
        const val NO_ID = ""
        const val NO_VERSION = 1L

        // hard, nonadjustable limits
        const val MONITOR_V2_MAX_TRIGGERS = 10
        const val MONITOR_V2_MIN_LOOK_BACK_WINDOW = 1L // 1 minute
        const val ALERTING_V2_MAX_NAME_LENGTH = 30 // max length of any name for monitors, triggers, notif actions, etc
        const val UUID_LENGTH = 20 // the length of a UUID generated by UUIDs.base64UUID()
        const val DESCRIPTION_MAX_LENGTH = 2000

        val XCONTENT_REGISTRY = NamedXContentRegistry.Entry(
            ScheduledJob::class.java,
            ParseField(MONITOR_V2_TYPE),
            CheckedFunction { parse(it) }
        )

        @JvmStatic
        @Throws(IOException::class)
        fun parse(xcp: XContentParser, id: String = NO_ID, version: Long = NO_VERSION): MonitorV2 {
            /* parse outer object for monitorV2 type, then delegate to correct monitorV2 parser */

            XContentParserUtils.ensureExpectedToken( // outer monitor object start
                XContentParser.Token.START_OBJECT,
                xcp.currentToken(),
                xcp
            )

            // monitor type field name
            XContentParserUtils.ensureExpectedToken(XContentParser.Token.FIELD_NAME, xcp.nextToken(), xcp)
            val monitorTypeText = xcp.currentName()
            val monitorType = MonitorV2Type.enumFromString(monitorTypeText)
                ?: throw IllegalStateException(
                    "when parsing MonitorV2, received invalid monitor type: $monitorTypeText. " +
                        "Please ensure monitor object is wrapped in an outer $PPL_SQL_MONITOR_TYPE object"
                )

            // inner monitor object start
            XContentParserUtils.ensureExpectedToken(XContentParser.Token.START_OBJECT, xcp.nextToken(), xcp)

            return when (monitorType) {
                MonitorV2Type.PPL_SQL_MONITOR -> PPLSQLMonitor.parse(xcp, id, version)
            }
        }

        fun readFrom(sin: StreamInput): MonitorV2 {
            return when (val monitorType = sin.readEnum(MonitorV2Type::class.java)) {
                MonitorV2Type.PPL_SQL_MONITOR -> PPLSQLMonitor(sin)
                else -> throw IllegalStateException("Unexpected input \"$monitorType\" when reading MonitorV2")
            }
        }

        fun writeTo(out: StreamOutput, monitorV2: MonitorV2) {
            when (monitorV2) {
                is PPLSQLMonitor -> {
                    out.writeEnum(MonitorV2Type.PPL_SQL_MONITOR)
                    monitorV2.writeTo(out)
                }
            }
        }
    }
}
