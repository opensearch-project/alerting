/*
 * Copyright OpenSearch Contributors
 * SPDX-License-Identifier: Apache-2.0
 */

package org.opensearch.alerting.modelv2

import org.opensearch.alerting.modelv2.PPLSQLMonitor.Companion.PPL_SQL_MONITOR_TYPE
import org.opensearch.common.CheckedFunction
import org.opensearch.commons.alerting.model.Schedule
import org.opensearch.commons.alerting.model.ScheduledJob
import org.opensearch.commons.authuser.User
import org.opensearch.core.ParseField
import org.opensearch.core.common.io.stream.StreamInput
import org.opensearch.core.common.io.stream.StreamOutput
import org.opensearch.core.xcontent.NamedXContentRegistry
import org.opensearch.core.xcontent.ToXContent
import org.opensearch.core.xcontent.XContentBuilder
import org.opensearch.core.xcontent.XContentParser
import org.opensearch.core.xcontent.XContentParserUtils
import java.io.IOException
import java.time.Instant

interface MonitorV2 : ScheduledJob {
    override val id: String
    override val version: Long
    override val name: String
    override val enabled: Boolean
    override val schedule: Schedule
    override val lastUpdateTime: Instant // required for scheduled job maintenance
    override val enabledTime: Instant? // required for scheduled job maintenance
    val description: String?
    val user: User?
    val triggers: List<TriggerV2>
    val schemaVersion: Int // for updating monitors
    val lookBackWindow: Long? // how far back to look when querying data during monitor execution
    val timestampField: String? // field that will be used to inject lookback window time filter

    fun asTemplateArg(): Map<String, Any?>

    fun toXContentWithUser(builder: XContentBuilder, params: ToXContent.Params): XContentBuilder

    fun makeCopy(
        id: String = this.id,
        version: Long = this.version,
        name: String = this.name,
        enabled: Boolean = this.enabled,
        schedule: Schedule = this.schedule,
        lastUpdateTime: Instant = this.lastUpdateTime,
        enabledTime: Instant? = this.enabledTime,
        description: String? = this.description,
        user: User? = this.user,
        // no support for overriding triggers in interface-level makeCopy(),
        // triggers can be copied at instance-level data class copy()
        schemaVersion: Int = this.schemaVersion,
        lookBackWindow: Long? = this.lookBackWindow,
        timestampField: String? = this.timestampField
    ): MonitorV2

    enum class MonitorV2Type(val value: String) {
        PPL_MONITOR(PPL_SQL_MONITOR_TYPE);

        override fun toString(): String {
            return value
        }

        companion object {
            fun enumFromString(value: String): MonitorV2Type? {
                return MonitorV2Type.entries.find { it.value == value }
            }
        }
    }

    companion object {
        // scheduled job field names
        const val MONITOR_V2_TYPE = "monitor_v2" // scheduled job type is MonitorV2

        // field names
        const val NAME_FIELD = "name"
        const val ENABLED_FIELD = "enabled"
        const val SCHEDULE_FIELD = "schedule"
        const val LAST_UPDATE_TIME_FIELD = "last_update_time"
        const val ENABLED_TIME_FIELD = "enabled_time"
        const val DESCRIPTION_FIELD = "description"
        const val USER_FIELD = "user"
        const val TRIGGERS_FIELD = "triggers"
        const val SCHEMA_VERSION_FIELD = "schema_version"
        const val LOOK_BACK_WINDOW_FIELD = "look_back_window_minutes"
        const val TIMESTAMP_FIELD = "timestamp_field"

        // default values
        const val NO_ID = ""
        const val NO_VERSION = 1L

        // hard, nonadjustable limits
        const val MONITOR_V2_MAX_TRIGGERS = 10
        const val MONITOR_V2_MIN_LOOK_BACK_WINDOW = 1L // 1 minute
        const val ALERTING_V2_MAX_NAME_LENGTH = 30 // max length of any name for monitors, triggers, notif actions, etc
        const val UUID_LENGTH = 20 // the length of a UUID generated by UUIDs.base64UUID()
        const val DESCRIPTION_MAX_LENGTH = 2000

        val XCONTENT_REGISTRY = NamedXContentRegistry.Entry(
            ScheduledJob::class.java,
            ParseField(MONITOR_V2_TYPE),
            CheckedFunction { parse(it) }
        )

        @JvmStatic
        @Throws(IOException::class)
        fun parse(xcp: XContentParser, id: String = NO_ID, version: Long = NO_VERSION): MonitorV2 {
            /* parse outer object for monitorV2 type, then delegate to correct monitorV2 parser */

            XContentParserUtils.ensureExpectedToken( // outer monitor object start
                XContentParser.Token.START_OBJECT,
                xcp.currentToken(),
                xcp
            )

            // monitor type field name
            XContentParserUtils.ensureExpectedToken(XContentParser.Token.FIELD_NAME, xcp.nextToken(), xcp)
            val monitorTypeText = xcp.currentName()
            val monitorType = MonitorV2Type.enumFromString(monitorTypeText)
                ?: throw IllegalStateException(
                    "when parsing MonitorV2, received invalid monitor type: $monitorTypeText. " +
                        "Please ensure monitor object is wrapped in an outer ppl_sql_monitor object"
                )

            // inner monitor object start
            XContentParserUtils.ensureExpectedToken(XContentParser.Token.START_OBJECT, xcp.nextToken(), xcp)

            return when (monitorType) {
                MonitorV2Type.PPL_MONITOR -> PPLSQLMonitor.parse(xcp, id, version)
            }
        }

        fun readFrom(sin: StreamInput): MonitorV2 {
            return when (val monitorType = sin.readEnum(MonitorV2Type::class.java)) {
                MonitorV2Type.PPL_MONITOR -> PPLSQLMonitor(sin)
                else -> throw IllegalStateException("Unexpected input \"$monitorType\" when reading MonitorV2")
            }
        }

        fun writeTo(out: StreamOutput, monitorV2: MonitorV2) {
            when (monitorV2) {
                is PPLSQLMonitor -> {
                    out.writeEnum(MonitorV2Type.PPL_MONITOR)
                    monitorV2.writeTo(out)
                }
            }
        }
    }
}
